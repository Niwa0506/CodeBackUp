#include <stdio.h>
#include <limits.h>

#define keytype int

#define LIMIT 300

/* ソート対象データ */
int data300[] = {
48, 185, 201, 162, 230, 8, 210, 281, 270, 157,
2, 261, 188, 279, 101, 195, 158, 50, 171, 153,
198, 148, 152, 71, 56, 63, 112, 64, 190, 96,
32, 66, 294, 53, 234, 39, 25, 97, 174, 200,
179, 125, 36, 180, 114, 238, 193, 288, 23, 173,
203, 126, 10, 40, 11, 253, 292, 105, 90, 34,
182, 177, 84, 22, 165, 254, 264, 243, 184, 298,
41, 89, 268, 142, 77, 06, 189, 226, 68, 111,
87, 223, 4, 95, 260, 186, 124, 122, 144, 176,
187, 191, 265, 108, 134, 194, 204, 102, 119, 128,
60, 15, 72, 249, 222, 202, 295, 82, 145, 240,
258, 219, 85, 136, 199, 161, 269, 290, 259, 256,
236, 277, 30, 33, 139, 38, 262, 69, 167, 121,
120, 272, 169, 55, 250, 79, 110, 106, 86, 154,
21, 5, 76, 220, 129, 78, 271, 18, 284, 166,
164, 9, 246, 29, 216, 217, 143, 74, 245, 247,
28, 273, 197, 291, 209, 170, 104, 141, 94, 62,
115, 242, 278, 232, 75, 45, 14, 297, 212, 275,
214, 37, 13, 132, 196, 163, 172, 44, 235, 107,
81, 67, 251, 168, 3, 289, 285, 137, 93, 282,
178, 65, 150, 287, 61, 47, 88, 224, 117, 241,
205, 239, 283, 7, 213, 211, 27, 46, 12, 237,
146, 127, 192, 83, 42, 116, 175, 227, 100, 59,
159, 118, 248, 244, 58, 274, 181, 103, 228, 257,
43, 225, 98, 267, 207, 231, 156, 218, 113, 17,
299, 229, 130, 266, 24, 138, 221, 109, 26, 16,
51, 155, 135, 92, 183, 149, 35, 208, 70, 49,
233, 160, 91, 293, 131, 276, 280, 54, 80, 99,
286, 57, 31, 140, 20, 147, 1, 133, 52, 255,
263, 73, 151, 123, 252, 19, 0, 206, 215, 296,
};


typedef struct {
  keytype key;
} recordtype;

recordtype a[LIMIT+1];


/* 全レコードを表示 (nはレコード数） */
void print_record(recordtype a[], int n){
  int i;

  for(i=1; i<=n; i++){  
    printf("%d, ", a[i].key);
  }

  printf("\n");
}


void init_data(recordtype *x){
  int i;

  for(i=0; i<LIMIT; i++){
    x[i+1].key = data300[i];  /* 配列dataをrecordtype配列のメンバkeyにコピー */
  }

  printf("[Initialized Data]\n");
  print_record(x, LIMIT);
}


void mergesort ( recordtype a[], int l, int r ){
     int i, j, k, m; recordtype b[LIMIT+1];  /* この実装ではLIMIT +1まで必要 */

     if ( l < r ) {
        m= (l+r)/2;
        mergesort(a,l,m);mergesort(a,m+1,r);
        for(i=m;i>=l;i--){b[i]= a[i];}
        i = l;
        for(j=m+1;j<=r;j++){b[r-(j-(m+1))] =a[j];}
        j = r;
      for(k = l;k <=r;k++){
        if(b[i].key <b[j].key){a[k]=b[i++];}
        else{a[k]=b[j--];}
      }
    }
}




int main(void){

  init_data(a);

  mergesort(a, 1, LIMIT);
  
  printf("\n[Merge Sort]\n");
  print_record(a, LIMIT);
  
}
